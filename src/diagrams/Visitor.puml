@startuml

interface Function {
    + <E> E accept(Visitor<E> visitor)
}

class Value implements Function{
    - value: double
    + getValue(): double
    + accept(Visitor<E> visitor): E
}

class Variable implements Function{
    - name: string
    + getName(): string
    + accept(Visitor<E> visitor): E
}

class Addition implements Function{
    - function1: Function
    - function2: Function
    + getFunction1(): Function
    + getFunction2(): Function
    + accept(Visitor<E> visitor): E
}

class Subtract implements Function{
    - function1: Function
    - function2: Function
    + getFunction1(): Function
    + getFunction2(): Function
    + accept(Visitor<E> visitor): E
}

class Multiplication implements Function{
    - function1: Function
    - function2: Function
    + getFunction1(): Function
    + getFunction2(): Function
    + accept(Visitor<E> visitor): E
}

class Division implements Function{
    - function1: Function
    - function2: Function
    + getFunction1(): Function
    + getFunction2(): Function
    + accept(Visitor<E> visitor): E
}

class SquareRoot implements Function{
    - function1: Function
    + getFunction(): Function
    + accept(Visitor<E> visitor): E
}

class Power implements Function{
    - function1: Function
    - function2: Function
    + getFunction1(): Function
    + getFunction2(): Function
    + accept(Visitor<E> visitor): E
}

class Absolute implements Function{
    - function1: Function
    + getFunction(): Function
    + accept(Visitor<E> visitor): E
}

interface Visitor{
    + visit(Absolute)
    + visit(Addition)
    + visit(Division)
    + visit(Multiplication)
    + visit(SquareRoot)
    + visit(Subtraction)
    + visit(Value)
    + visit(Variable)
}

Function -> Visitor

class PrintVisitor implements Visitor{
    + print(Function)
}

class CalculateVisitor implements Visitor{
    + evaluate(Function)
}

class VariableVisitor implements Visitor{
    + getVariables(Function)
}

@enduml
class Negate implements Function{
    value: Function
}